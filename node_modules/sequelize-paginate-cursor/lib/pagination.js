'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

/**
 * Created by mirabalj on 10/12/16.
 */

exports.default = function (Model) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  let name = _ref.name;

  // Pagination using cursor is here!
  const results = (() => {
    var _ref2 = _asyncToGenerator(function* () {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      let sinceId = _ref3.sinceId,
          maxId = _ref3.maxId;
      var _ref3$limit = _ref3.limit;
      let limit = _ref3$limit === undefined ? 1 : _ref3$limit,
          select = _ref3.select;
      var _ref3$where = _ref3.where;
      let where = _ref3$where === undefined ? {} : _ref3$where;
      var _ref3$keyPaginated = _ref3.keyPaginated;
      let keyPaginated = _ref3$keyPaginated === undefined ? 'id' : _ref3$keyPaginated;
      var _ref3$reverse = _ref3.reverse;
      let reverse = _ref3$reverse === undefined ? false : _ref3$reverse;
      var _ref3$include = _ref3.include;
      let include = _ref3$include === undefined ? [] : _ref3$include;
      var _ref3$subQuery = _ref3.subQuery;
      let subQuery = _ref3$subQuery === undefined ? true : _ref3$subQuery;
      let callback = arguments[1];

      try {
        const lsThanE = reverse ? '$gte' : '$lte';
        const lsThan = reverse ? '$gt' : '$lt';
        const gsThan = reverse ? '$lt' : '$gt';
        const findObject = where;
        const findCursor = {};

        if (sinceId) {
          findCursor[lsThanE] = sinceId;
          findObject[keyPaginated] = findCursor;
        }

        if (maxId) {
          findCursor[gsThan] = maxId;
          findObject[keyPaginated] = findCursor;
        }

        // Assign order of search
        const order = keyPaginated + (reverse ? '' : ' DESC');

        // Execute query with limit
        const objects = yield this.findAll({
          where: where,
          subQuery: subQuery,
          include: include,
          limit: limit,
          attributes: select,
          order: order
        });

        let nextCursor = undefined;
        const len = objects.length;

        // Search fine? create a cursor!
        if (len) {
          const lastCursor = objects[len - 1][keyPaginated];
          const findNextCursorWhere = where;
          const findNextCursor = {};
          findNextCursor[lsThan] = lastCursor;
          findNextCursorWhere[keyPaginated] = findNextCursor;
          // Find next cursor
          const nextObject = yield this.findOne({
            where: findNextCursorWhere,
            subQuery: subQuery,
            include: include,
            order: order
          });
          // Exist next cursor?
          if (nextObject) {
            nextCursor = nextObject[keyPaginated];
          }
        }

        // Create paginate object
        const objectReturn = {
          objects: objects,
          nextCursor: nextCursor
        };

        // Call back, Â¿exist?
        if (callback) {
          callback(null, objectReturn);
        }

        // Return paginate
        return objectReturn;
      } catch (err) {
        // Catch error and send to callback
        if (callback) callback(err);
        throw err;
      }
    });

    function any() {
      return _ref2.apply(this, arguments);
    }

    return any;
  })();
  // Assign the function as the name identifier
  if (name) {
    Model[name] = results;
  } else {
    Model.paginate = results;
  }
};
//# sourceMappingURL=pagination.js.map